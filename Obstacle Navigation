
//wheels
int LeftWheel_In3 = 2;
int LeftWheel_In4 = 4;
int LeftEnable = 6;
int RightWheel_In2 = 8;
int RightWheel_In1 = 7;
int RightEnable = 5;

//US Sensor
int NavTrigger = 10;
int NavEcho = 9;

//WIFI
int CameraRX = 3;
int CameraTX = 12;

float x_coord = 0;
float y_coord = 0;
float RotationTheta = 0;

float x_desired = 3.35;
float y_desired = 0;

int DriveSpeed = 0;
float cm;
  
void setup()
{
  pinMode(LeftWheel_In3, OUTPUT);
  pinMode(LeftWheel_In4, OUTPUT);
  pinMode(RightWheel_In2, OUTPUT);
  pinMode(RightWheel_In1, OUTPUT);
  
  pinMode(LeftEnable, OUTPUT);
  pinMode(RightEnable, OUTPUT);

  pinMode(NavTrigger, OUTPUT);
  pinMode(NavEcho, INPUT);
  
  pinMode(CameraRX, INPUT);
  pinMode(CameraTX, OUTPUT);
  

}



void loop()  //obstacles with GoTo function
{
  ReverseDrive(50); //move out of mission site
  delay(500);
  StopDrive();

  GoTo(starting x, starting y); //where we start the naigation 
  TurnLeftTo(1.571);
  GoTo(first x, first y);
  Obstacle();
  if (!Obstacle) 
  {
    GoTo (1st x + 0.5, 1st y);
  }
  if (Obstacle) GoTo(2nd x, 2nd y);
  
  
}
bool Obstacle();
float cm = distance();

  if (cm <= 8.00) {
  return true;
  } 
  else {
    return false;
  }
}
  
// Position OTV in front of the first set of obstacles
void loop()
{
  while(RotationTheta != 0) { // 0 is facing the East side of the board
	LeftTurn_Inplace ();
	}
  StopDrive();
  
  while(x_coord != a) { // Will need to find a coord
    ForwardDrive();
  	}
  StopDrive();
  	
  while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
	LeftTurn_Inplace ();
	}
  StopDrive();
  
  while(y_coord != b) { // Will need to find b coord
    ForwardDrive();
  	}
} // Should be facing the first obstacle (farthest )




// *** CLEAN UP THE FOLLOWING OBSTACLE DETECTION LOOPS!!! ***


void loop () // Obstacle detection and movement for FIRST set of obstacles
{
  
  while(cm >= # && x_coord != a2) { // Will need to implement Ultrasonic code and find a_coord
    ForwardDrive();
  	}
  StopDrive();
	
  while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
	LeftTurn_Inplace ();
	}
  StopDrive();
  
  while(y_coord != b) { // Will need to find b1 coord to face the second obstacle
    ForwardDrive();
  	}
  StopDrive(); 
  
  while(RotationTheta != 0) { // 0 is facing the North side of the board
	RightTurn_Inplace ();
	}
  StopDrive();
  
  while(cm >= # && x_coord != a2) { // Will need to implement Ultrasonic code
    ForwardDrive();
  	}
  StopDrive();
	
  while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
	LeftTurn_Inplace ();
	}
  StopDrive();
  
  while(y_coord != c) { // Will need to find c1 coord to face the second obstacle
    ForwardDrive();
  	}
  StopDrive();
  
  while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
    RightTurn_Inplace ();
  	}
  StopDrive();
  
  if (y_coord == c && cm >= #) // This will run once it has checked the first two obstacles
    ForwardDrive ();
}



// OTV will not be in a predicted location, so to start the obstacle detection loop, we will place the OTV infront of Obstacle a2

void loop () { // Obstacle detection and movement for SECOND set of obstacles  
  while (x_coord == b)
    
    while(y_coord != a) {// Will need to find a coord
    	while(RotationTheta != 0) { // Can use the GOTO function instead
    		LeftTurn_Inplace ();
    		}
  		StopDrive();
  		
  		while(cm >= a) { // Will move toward the wall until y_coord is met
        	ForwardDrive();
        	}
  		StopDrive(); 
  
  		while(RotationTheta != 1.571) {
        	RightTurn_Inplace ();
        	}
  		StopDrive(); // Should be in front of the first obstacle of the second set
  
  	while(cm >= #) { // Will need to implement Ultrasonic code
    	ForwardDrive();
  		}
  	StopDrive();
	
  	while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
		LeftTurn_Inplace ();
		}
  	StopDrive();
  
  	while(y_coord != b) { // Will need to find b2 coord to face the second obstacle
    	ForwardDrive();
  		}
  	StopDrive(); 
  
  	while(RotationTheta != 0) { // 0 is facing the North side of the board
		LeftTurn_Inplace ();
		}
  	StopDrive();
  
  	while(cm >= #) { // Will need to implement Ultrasonic code
    	ForwardDrive();
  		}
  	StopDrive();
	
  	while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
		RightTurn_Inplace ();
		}
  	StopDrive();
  
  	while(y_coord != c) { // Will need to find c2 coord to face the second obstacle
    	ForwardDrive();
  		}
  	StopDrive(); 
}
  
void GoTo (float x, float y) {

 
    if (y_coord < y) TurnLeftTo(1.571);
    if (y_coord > y) TurnLeftTo(-1.571);

  		while(abs(y_coord - y) > 0.1) { // Will move toward the wall until y_coord is met
        	ForwardDrive(10);
          y_coord = Enes100.getY();
            delay(10);
        	}
  		StopDrive();
    
    if (x_coord < x) TurnLeftTo(0.0);
    if (x_coord > x) TurnLeftTo(3.1416);
    StopDrive();
  		while(abs(x_coord - x) > 0.1) { // Will move toward the wall until y_coord is met
        	ForwardDrive(10);
          x_coord = Enes100.getX();
            delay(10);
        	}
  		StopDrive();
  	
    }
  
      

// Ultrasonic functions from Searchable Google Drive
// ***pin numbers may be needed to be changed
 
float distance() { 
  long duration;
  digitalWrite(NavTrigger, LOW);
  delayMicroseconds(5);
  digitalWrite(NavTrigger, HIGH);
  delayMicroseconds(10);
  digitalWrite(NavTrigger, LOW);
 
  // Read the signal from the sensor
  pinMode(NavEcho, INPUT);
  duration = pulseIn(NavEcho, HIGH);
 
  cm = (duration/2) / 29.1;     // Divide by 29.1 or multiply by 0.0343
  delay(250);
  return cm;
}




void TurnLeftTo (float theta) { // Turning left until RotationTheta is met
   while(RotationTheta != theta) {
	LeftTurn_Inplace ();
	}
  StopDrive();
}

void TurnRightTo (float theta) { // Turning right until RotationTheta is met
   while(RotationTheta != theta) {
	RightTurn_Inplace ();
	}
  StopDrive();
}



void ForwardDrive (int speed) //drives forward, set a speed 0 to 255
{
  if (speed < 0) speed = 0;
  if (speed > 225) speed = 225; //speed cant go above 225 or below 0
  
  
  analogWrite(LeftEnable, speed);
  analogWrite(RightEnable, speed);
  
  digitalWrite(LeftWheel_In3, HIGH);
  digitalWrite(LeftWheel_In4, LOW);
  
  digitalWrite(RightWheel_In1, HIGH);
  digitalWrite(RightWheel_In2, LOW);  
}


void ReverseDrive (int speed) //drives backward, set a speed 0 to 255
{
  if (speed < 0) speed = 0;
  if (speed > 225) speed = 225; //speed cant go above 225 or below 0
  
  DriveSpeed = speed;
  
  analogWrite(LeftEnable, speed);
  analogWrite(RightEnable, speed);
  
  digitalWrite(LeftWheel_In3, LOW);
  digitalWrite(LeftWheel_In4, HIGH);
  
  digitalWrite(RightWheel_In1, LOW);
  digitalWrite(RightWheel_In2, HIGH);
}

void StopDrive ()  //determine later if decceleration is needed
{
  digitalWrite(LeftWheel_In3, LOW);
  digitalWrite(LeftWheel_In4, LOW);
  
  digitalWrite(RightWheel_In1, LOW);
  digitalWrite(RightWheel_In2, LOW);
  
  analogWrite(LeftEnable, 0);
  analogWrite(RightEnable, 0);
}

void LeftTurn_Inplace (int speed)
{
  analogWrite(LeftEnable, speed); //speed subject to change
  analogWrite(RightEnable, speed);
  
  digitalWrite(LeftWheel_In3, LOW);
  digitalWrite(LeftWheel_In4, HIGH);
  
  digitalWrite(RightWheel_In1, HIGH);
  digitalWrite(RightWheel_In2, LOW);
}

void RightTurn_Inplace (int speed) 
{
  analogWrite(LeftEnable, speed); //speed subject to change
  analogWrite(RightEnable, speed);
  
  digitalWrite(LeftWheel_In3, HIGH);
  digitalWrite(LeftWheel_In4, LOW);
  
  digitalWrite(RightWheel_In1, LOW);
  digitalWrite(RightWheel_In2, HIGH);
}
