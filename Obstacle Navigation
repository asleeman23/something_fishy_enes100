
//wheels
int LeftWheel_In3 = 2;
int LeftWheel_In4 = 4;
int LeftEnable = 6;
int RightWheel_In2 = 8;
int RightWheel_In1 = 7;
int RightEnable = 5;

//US Sensor
int NavTrigger = 10;
int NavEcho = 9;

//WIFI
int CameraRX = 3;
int CameraTX = 12;

float x_coord = 0;
float y_coord = 0;
float RotationTheta = 0;

float x_desired = 3.35;
float y_desired = 0;

int DriveSpeed = 0;
  
void setup()
{
  pinMode(LeftWheel_In3, OUTPUT);
  pinMode(LeftWheel_In4, OUTPUT);
  pinMode(RightWheel_In2, OUTPUT);
  pinMode(RightWheel_In1, OUTPUT);
  
  pinMode(LeftEnable, OUTPUT);
  pinMode(RightEnable, OUTPUT);

  pinMode(NavTrigger, OUTPUT);
  pinMode(NavEcho, INPUT);
  
  pinMode(CameraRX, INPUT);
  pinMode(CameraTX, OUTPUT);
  

}



void loop()
{
  while(RotationTheta != 0) { // 0 is facing the East side of the board
	LeftTurn_Inplace ();
	}
  StopDrive();
  
  while(x_coord != a) { // Will need to find a coord
    ForwardDrive();
  	}
  StopDrive();
  	
  while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
	LeftTurn_Inplace ();
	}
  StopDrive();
  
  while(y_coord != b) { // Will need to find b coord
    ForwardDrive();
  	}
} // Should be facing the first obstacle (farthest )




// *** CLEAN UP THE FOLLOWING OBSTACLE DETECTION LOOPS!!! ***


void loop () // Obstacle detection and movement for first set of obstacles
{
  while (x_coord == a) //  May need to make this a range because of the turning, the OTV's x_coord may change despite still being in the first set of obstacles
  	while(cm >= #) { // Will need to implement Ultrasonic code
    	ForwardDrive();
  		}
  	StopDrive();
	
  	while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
		RightTurn_Inplace ();
		}
  	StopDrive();
  
  	while(y_coord != b) { // Will need to find b1 coord to face the second obstacle
    	ForwardDrive();
  		}
  	StopDrive(); 
  
  	while(RotationTheta != 0) { // 0 is facing the North side of the board
		LeftTurn_Inplace ();
		}
  	StopDrive();
  
  	while(cm >= #) { // Will need to implement Ultrasonic code
    	ForwardDrive();
  		}
  	StopDrive();
	
  	while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
		RightTurn_Inplace ();
		}
  	StopDrive();
  
  	while(y_coord != c) { // Will need to find c1 coord to face the second obstacle
    	ForwardDrive();
  		}
  	StopDrive();
	}

// For second set of obstacles, OTV will not be in a predicted location, so to start the obstacle detection loop, we will place the OTV infront of Obstacle a2

void loop () { // Obstacle detection and movement for second set of obstacles  
  while (x_coord == b)
    
    while(y_coord != a) // Will need to find a coord
    	while(RotationTheta != 0) {
    		LeftTurn_Inplace ();
    		}
  		StopDrive();
  		
  		while(cm >= #) { // Will move toward the wall until y_coord is met
        	ForwardDrive();
        	}
  		StopDrive(); 
  
  		while(RotationTheta != 1.571) {
        	RightTurn_Inplace ();
        	}
  		StopDrive(); // Should be in front of the first obstacle of the second set
  
  	while(cm >= #) { // Will need to implement Ultrasonic code
    	ForwardDrive();
  		}
  	StopDrive();
	
  	while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
		RightTurn_Inplace ();
		}
  	StopDrive();
  
  	while(y_coord != b) { // Will need to find b2 coord to face the second obstacle
    	ForwardDrive();
  		}
  	StopDrive(); 
  
  	while(RotationTheta != 0) { // 0 is facing the North side of the board
		LeftTurn_Inplace ();
		}
  	StopDrive();
  
  	while(cm >= #) { // Will need to implement Ultrasonic code
    	ForwardDrive();
  		}
  	StopDrive();
	
  	while(RotationTheta != 1.571) { // 1.571 is facing the North side of the board
		RightTurn_Inplace ();
		}
  	StopDrive();
  
  	while(y_coord != c) { // Will need to find c2 coord to face the second obstacle
    	ForwardDrive();
  		}
  	StopDrive(); 
}
  


// Ultrasonic functions from Searchable Google Drive
int trigPin = 10;    // Trigger 
// ***pin numbers may be incorrect
int echoPin = 11;    // Echo
long duration, cm, inches;
 
void setup() {
  Serial.begin (9600);
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
}
 
void loop() { // The sensor is triggered by a HIGH pulse of 10 or more microseconds 
  // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:
  digitalWrite(trigPin, LOW);
  delayMicroseconds(5);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
 
  // Read the signal from the sensor
  pinMode(echoPin, INPUT);
  duration = pulseIn(echoPin, HIGH);
 
  cm = (duration/2) / 29.1;     // Divide by 29.1 or multiply by 0.0343
  inches = (duration/2) / 74;   // Divide by 74 or multiply by 0.0135
  Serial.print(inches);
  Serial.print("in, ");
  Serial.print(cm);
  Serial.print("cm");
  Serial.println();
  delay(250);
}




void TurnLeftTo (float theta) { // Turning left until RotationTheta is met
   while(RotationTheta != theta) {
	LeftTurn_Inplace ();
	}
  StopDrive();
}

void TurnRightTo (float theta) { // Turning right until RotationTheta is met
   while(RotationTheta != theta) {
	RightTurn_Inplace ();
	}
  StopDrive();
}



void ForwardDrive (int speed) //drives forward, set a speed 0 to 255
{
  if (speed < 0) speed = 0;
  if (speed > 225) speed = 225; //speed cant go above 225 or below 0
  
  analogWrite(LeftEnable, speed);
  analogWrite(RightEnable, speed);
  
  digitalWrite(LeftWheel_In3, HIGH);
  digitalWrite(LeftWheel_In4, LOW);
  
  digitalWrite(RightWheel_In1, HIGH);
  digitalWrite(RightWheel_In2, LOW);  
}


void ReverseDrive (int speed) //drives backward, set a speed 0 to 255
{
  if (speed < 0) speed = 0;
  if (speed > 225) speed = 225; //speed cant go above 225 or below 0
  
  DriveSpeed = speed;
  
  analogWrite(LeftEnable, speed);
  analogWrite(RightEnable, speed);
  
  digitalWrite(LeftWheel_In3, LOW);
  digitalWrite(LeftWheel_In4, HIGH);
  
  digitalWrite(RightWheel_In1, LOW);
  digitalWrite(RightWheel_In2, HIGH);
}

void StopDrive ()  //determine later if decceleration is needed
{
  digitalWrite(LeftWheel_In3, LOW);
  digitalWrite(LeftWheel_In4, LOW);
  
  digitalWrite(RightWheel_In1, LOW);
  digitalWrite(RightWheel_In2, LOW);
  
  analogWrite(LeftEnable, 0);
  analogWrite(RightEnable, 0);
}

void LeftTurn_Inplace ()
{
  analogWrite(LeftEnable, 10); //speed subject to change
  analogWrite(RightEnable, 10);
  
  digitalWrite(LeftWheel_In3, LOW);
  digitalWrite(LeftWheel_In4, HIGH);
  
  digitalWrite(RightWheel_In1, HIGH);
  digitalWrite(RightWheel_In2, LOW);
}

void RightTurn_Inplace () 
{
  analogWrite(LeftEnable, 100); //speed subject to change
  analogWrite(RightEnable, 100);
  
  digitalWrite(LeftWheel_In3, HIGH);
  digitalWrite(LeftWheel_In4, LOW);
  
  digitalWrite(RightWheel_In1, LOW);
  digitalWrite(RightWheel_In2, HIGH);
}
